using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using Godot;
using Godot.Collections;
using PinkDogMM_Gd.Core;
using PinkDogMM_Gd.Core.Schema;
using PinkDogMM_Gd.UltraBinder;

namespace PinkDogMM_Gd.Scenes.Elements;

public partial class ModelPropertyBinding(Node node, string watchedField, string propertyToUpdate) : Node
{
	public Node node;
	public string watchedField;
	public string propertyToUpdate;
}

public partial class PropertiesPanel : VBoxContainer
{
	private Part? selected;

	private Dictionary<string, Array<ModelPropertyBinding>> listeners = [];

	PropertiesPanel()
	{
		ChildEnteredTree += OnChildEnteredTree;
	}

	public override void _Ready()
	{
		//TODO there TOTALLY is a better way to do this that will be more compostable. not there yet tho..

		AppState appState = GetNode("/root/AppState") as AppState;

		Debug.Assert(appState != null, nameof(appState) + " != null");
		appState.ActiveModelChanged += index =>
		{
			Model model = appState.ActiveModel;

			model.State.SelectedParts.CollectionChanged += (sender, args) =>
			{
				SetVisiblity();
				if (model.State.SelectedParts.Count == 0)
				{
					selected = null;
					SetVisiblity();
				}

				selected = model.State.SelectedParts[0] as Part;
				selected.PropertyChanged += SelectedOnPropertyChanged;

				SetVisiblity();
			};
		};
	}

	public void SetVisiblity()
	{
		foreach (var child in GetChildren())
		{
			((Node3D)child).Visible = selected != null;
		}
	}
	private void SelectedOnPropertyChanged(object? sender, PropertyChangedEventArgs e)
	{
		if (sender == null) return;
		foreach (var keyValuePair in listeners)
		{
			if (keyValuePair.Key != e.PropertyName) continue;
			
			var value = sender.GetType().GetProperty(e.PropertyName)?.GetValue(e.PropertyName);
			
			foreach (var binding in keyValuePair.Value)
			{
				var controlProp = binding.node.GetType().GetProperty(binding.propertyToUpdate);
				if (controlProp == null)
				{
					GD.Print("Couldn't update property.");
					return;
				}

				controlProp.SetValue(binding.node, value);
			}
		}
	}
	
	

	private void OnChildEnteredTree(Node node)
	{
		Array<Node> children = node.GetChildren();
		if (children.Count != 0)
		{
			//Try to connect things.
			foreach (var child in children)
			{
				ConnectNode(child);
			}
		}

		GD.Print(node);
	}
	

	
	private void ConnectNode(Node node)
	{
		AppState appState = GetNode("/root/AppState") as AppState;
		if (node.HasMeta("WatchedField"))
		{
			string watchedField = node.GetMeta("WatchedField").AsString();
			string propertyToUpdate = node.GetMeta("PropertyToUpdate").AsString();

			if (!listeners.ContainsKey(watchedField)) listeners.Add(watchedField, []);
			//We might have to do some watching.
			node.Connect("text_changed", Callable.From(() =>
			{
				GD.Print("fdgdfgd");
			}));
			
			GD.Print(this.GetName() + " binded to " + watchedField);
		}

		Array<Node> children = node.GetChildren();
		if (children.Count == 0) return;
		//Try to connect things.
		foreach (var child in children)
		{
			ConnectNode(child); 
		}
		
	}
	
}
